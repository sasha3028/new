#include <iostream>
#include <conio.h>
#include <stdlib.h>
#include <cstdlib>
using namespace std;
/*Оставляю кучу комментариев. Читай внимательно и разбирайся. И не вздумай мне там ворчать, что и так все это знаешь:)*/
int main() 
{
	setlocale(LC_ALL, "RUS");
	int **a, **b,jb,ib,i,j,ni,nj,y,y_p,d,p;
	cout<<"Введите количество строк"<<" ";
	cin>>ni;
	cout<<"Введите количество столбцов"<<" ";
	cin>>nj;
	a=NULL;
	b=NULL;
	a=(int**)malloc(ni*sizeof(int*));
	if (a==NULL)
	{
		cout<<"Ошибка выделения памяти";
		_getch();
		return 0;
	}
	for (i=0; i<ni; i++)
		a[i]=(int*)malloc(nj*sizeof(int)); // для каждого из массива указателей выделяем nj единиц памяти на всю строку элементов
		if(a[i]==NULL)
		{
			cout<<"Ошибка выделения памяти";
			_getch();
			return 0;
		}
	for (i=0; i<ni; i++)
	{
		y_p=0;
		for(j=0; j<nj; j++)
		{
			cin>>a[i][j];
			if (a[i][j]<0)
				{
					y=-1;
				}
				else
				{
					y=1;
				}
			if (y_p!=0)
			{
				if(y!=y_p)
				{
					for (j=j+1; j<nj; j++)
					{
						a[i][j]=a[i][j-1];
					}
					break;
				}
			}
			y_p=y;
		}	
	}
	p=0;
	jb=0;
	for (j=0; j<nj; j++)
	{
		d=1;
		for (i=0; i<ni-1; i++)
		{
			if (a[i][j]>a[i+1][j])
			 {
			 	d=0;
			 }
		}
		if(d!=0)
		{
			b=(int**)realloc(b, nj*sizeof(int*)); /*realloc перевыделяет память для данных. Чтобы
			получить память нужно что-то отдать. А именно - мусор, хранящийся изначально где-то в памяти
			Но сам мусор мы не можем передать. По этому в самом начале программы мы написали
			В = NULL. То есть мы присвоили нули определенной части массива. Эти нули в последствии передадутся
			в realloc и превратятся в память. И кстати строчка кода неверна. Или.. А не, все норм*/
			if (b==NULL)
			{
				cout<<"Ошибка выделения памяти";
				_getch();
				return 0;
			}
			b[jb]=(int*)malloc(ni*sizeof(int)); /* а malloc уже ВЫделяет память. В этом вся разница. С каждым проходом
			цикла, ты на строку выделяешь ni единиц памяти(клеточек, блоков - называй как хочешь) */
			if (b[jb]==NULL)
			{
				cout<<"Ошибка выделения памяти";
				_getch();
				return 0;
			} /*по сути, у тебя должно быть еще в этом цикле return 0; Ставь, если 
				сработает. Эта запись означает, что если память не выделяется - то наступает конец программы и она автоматически завершается.
				Где-то, в с++, иногда не работает return, тогда используешь тупо else. Если ошибка выделения
				- то сообщение, иначе - продолжаешь программу. Таким образом я сделала самую первую проверку, если ты
				вернешься наверх и внимательно посмотришь, то увидишь)*/
			for (i=0; i<ni; i++)
			{	
				b[jb][i]=a[i][j];
			}
			p++;
			jb++;
		}
	}	
	cout<<"Исходный массив:";
	cout<<endl;
	for (i=0; i<ni; i++)
	{
		for(j=0; j<nj; j++)
		{
			cout<<a[i][j];
		}
		cout<<endl;	
	}  
	cout<<"Результирующий массив:";
	cout<<endl;
	for (j=0; j<p; j++)
	{
		for(i=0; i<ni; i++)
		{
			cout<<b[j][i];
		}
		cout<<endl;	
	}  
	for( i=0; i<ni; i++)
	{
		free(a[i]);
	}
	free(a);
	a=NULL;
	for( j=0; j<p; j++)
	{
		free(b[j]);
	}
	free(b);
	b=NULL;
_getch();
return 0;
}
